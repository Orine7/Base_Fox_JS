"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
require("dotenv/config");
const devkit_1 = require("@nrwl/devkit");
const chalk = require("chalk");
const fs_1 = require("fs");
const path_1 = require("path");
const config_1 = require("../../utils/config");
const custom_server_1 = require("./lib/custom-server");
const default_server_1 = require("./lib/default-server");
const devkit_2 = require("@nrwl/devkit");
const buildable_libs_utils_1 = require("@nrwl/workspace/src/utilities/buildable-libs-utils");
const buildable_libs_1 = require("../../utils/buildable-libs");
const require_shim_1 = require("../../utils/require-shim");
const devkit_3 = require("@nrwl/devkit");
const { PHASE_DEVELOPMENT_SERVER, PHASE_PRODUCTION_SERVER } = (0, require_shim_1.importConstants)();
const infoPrefix = `[ ${chalk.dim(chalk.cyan('info'))} ] `;
const readyPrefix = `[ ${chalk.green('ready')} ]`;
function serveExecutor(options, context) {
    return tslib_1.__asyncGenerator(this, arguments, function* serveExecutor_1() {
        // Cast to any to overwrite NODE_ENV
        process.env.NODE_ENV = process.env.NODE_ENV
            ? process.env.NODE_ENV
            : options.dev
                ? 'development'
                : 'production';
        let dependencies = [];
        const buildTarget = (0, devkit_1.parseTargetString)(options.buildTarget);
        const baseUrl = `http://${options.hostname || 'localhost'}:${options.port}`;
        const buildOptions = (0, devkit_1.readTargetOptions)(buildTarget, context);
        const root = (0, path_1.resolve)(context.root, buildOptions.root);
        const libsDir = (0, path_1.join)(context.root, (0, devkit_3.workspaceLayout)().libsDir);
        if (!options.buildLibsFromSource) {
            const result = (0, buildable_libs_utils_1.calculateProjectDependencies)((0, devkit_2.readCachedProjectGraph)(), context.root, context.projectName, 'build', // should be generalized
            context.configurationName);
            dependencies = result.dependencies;
            (0, buildable_libs_1.assertDependentProjectsHaveBeenBuilt)(dependencies, context);
        }
        const config = yield tslib_1.__await((0, config_1.prepareConfig)(options.dev ? PHASE_DEVELOPMENT_SERVER : PHASE_PRODUCTION_SERVER, buildOptions, context, dependencies, libsDir));
        const settings = {
            dev: options.dev,
            dir: root,
            staticMarkup: options.staticMarkup,
            quiet: options.quiet,
            conf: config,
            port: options.port,
            path: options.customServerPath,
            hostname: options.hostname,
        };
        const server = options.customServerPath
            ? custom_server_1.customServer
            : default_server_1.defaultServer;
        // look for the proxy.conf.json
        let proxyConfig;
        const proxyConfigPath = options.proxyConfig
            ? (0, path_1.join)(context.root, options.proxyConfig)
            : (0, path_1.join)(root, 'proxy.conf.json');
        if ((0, fs_1.existsSync)(proxyConfigPath)) {
            devkit_1.logger.info(`${infoPrefix} found proxy configuration at ${proxyConfigPath}`);
            proxyConfig = require(proxyConfigPath);
        }
        try {
            yield tslib_1.__await(server(settings, proxyConfig));
            devkit_1.logger.info(`${readyPrefix} on ${baseUrl}`);
            yield yield tslib_1.__await({
                baseUrl,
                success: true,
            });
            // This Promise intentionally never resolves, leaving the process running
            yield tslib_1.__await(new Promise(() => { }));
        }
        catch (e) {
            if (options.dev) {
                throw e;
            }
            else {
                throw new Error(`Could not start production server. Try building your app with \`nx build ${context.projectName}\`.`);
            }
        }
    });
}
exports.default = serveExecutor;
//# sourceMappingURL=server.impl.js.map